lets take a scenario where i have 4 to 5 commits in a branch and i have deployed my latest deployed code but after deploying i got some issue in latest commit, now what i need to do i need to go back on 
previous commit or any other commit and deploy that code. what is the way of doing that.
Example repo state A --- B --- C --- D --- E   (main, HEAD)
	â€¢	E = latest commit (deployed, but broken âŒ).
	â€¢	You want to rollback to D (the last good commit âœ…).


Identify commits
git log --oneline
Example output:
abc123 (HEAD -> main) Fix bug (E)
def456 Add feature (D)
789abc Improve UI (C)

 Quick rollback (hot deploy old commit)
If you just want to deploy D code immediately:
git checkout def456
Your working directory now contains code from commit D.
Deploy this code to production. You are in detached HEAD state. Thatâ€™s fine for deployment but not good for long-term.

rollback in history
Revert commit E (safe for team projects)
git checkout main
git revert abc123   # this is commit Eâ€™s hash
git push origin main
Creates a new commit F that undoes E.
History now looks like:
A --- B --- C --- D --- E --- F (main, HEAD)
                        ^ revert of E
Production matches D, but history is preserved.
Best when working in a team,

What git revert does
When you run:
git checkout main
git revert abc123    # abc123 = commit E
Git doesnâ€™t delete commit E. Instead:
	â€¢	It creates a brand new commit (F) that does the opposite changes of commit E.
	â€¢	That means:
	â€¢	If E added a line â†’ F removes it.
	â€¢	If E deleted a line â†’ F adds it back.
	â€¢	If E modified a file â†’ F reverts it.
So now history looks like this:
A --- B --- C --- D --- E --- F   (main, HEAD)
                                ^
                                |
                        new commit "Revert E"
	â€¢	Production code = same as D.
	â€¢	But history shows everything:
	â€¢	â€œWe made commit E.â€
	â€¢	â€œThen we reverted it with commit F.â€

âœ… This is why revert is safe for teams â†’ no history rewriting, everyoneâ€™s history stays consistent.

âœ… So the rule is:
	â€¢	git revert <commit> = â€œtake the diff that commit introduced, and apply the opposite of that diff to the current state (HEAD).â€

Thatâ€™s why revert is so powerful â€” you can run it at any point in history and it will still just apply a patch to your current branch.




Situation:- below is the initial state
A --- B --- C --- D --- E   (main)
what i need to do i need to quicky deploy commit D and again start working and fixing E what should i do revert or checkout to D?
Quick rollback for deployment (fast recovery)
Do not revert yet, just checkout D and deploy:
git checkout D
# now working directory has commit D's code
# build/deploy this to production
his is the fastest way to get production stable again.
Youâ€™re in detached HEAD state, but thatâ€™s fine for deployment.
Step 2: Keep working on fixes in main

Stay on main (which is still pointing at E).
Fix the bug in commit E, then commit the fix:
git checkout main
# fix code
git commit -m "Fix issue introduced in E"
git push origin main
Now history is:
A --- B --- C --- D --- E --- F   (main, HEAD)
                                ^
                                fix commit



	â€¢	Production is running D.
	â€¢	Repo history has E (bad) and F (fix).

When youâ€™re confident F works, redeploy main to production.

History before revert
A --- B --- C --- D (HEAD -> main)
	â€¢	B introduced some changes.
	â€¢	C was created on top of B, so yes, Câ€™s snapshot contains A + B + C changes.
	â€¢	D snapshot = A + B + C + D.

After git revert B
A --- B --- C --- D --- E (HEAD -> main)
            ^
            |
     new commit E = "undo B"
Now the important part:
	â€¢	git revert B does not remove commit B from history.
	â€¢	It just applies the inverse of commit Bâ€™s changes on top of current HEAD (D).
	â€¢	So working directory after E looks like:
(A + B + C + D) - (changes introduced by B)

ğŸ”¹ Does Câ€™s code change too?

ğŸ‘‰ No.
	â€¢	C still exists in history exactly as it was (A + B + C).
	â€¢	But when youâ€™re at E, your code = â€œA + C + D, without Bâ€™s changesâ€.

So:
	â€¢	C itself doesnâ€™t get rewritten.
	â€¢	But the active working tree (at E) no longer includes the effects of B.


